---
title: 多线程部分面试题
date: 2020-08-03 20:19:54
tags: 面试题
categories: 面试题
---

1. 并行和并发有什么区别？

   - 并行指多个事件在同一个时刻发生；并发指在某时刻只有一个事件在发生，某个时间段内由于 CPU 交替执行，可以发生多个事件。
   - 并行没有对 CPU 资源的抢占；并发执行的线程需要对 CPU 资源进行抢占。
   - 并行执行的线程之间不存在切换；并发操作系统会根据任务调度系统给线程分配线程的 CPU 执行时间，线程的执行会进行切换。

2. 线程和进程有什么区别？

3. 守护线程是什么？

   守护线程是程序运行的时候在后台提供一种通用服务的线程。所有用户线程停止，进程会停掉所有守护线程，退出程序。

4. 创建线程有哪几种方式？

   1. **重写 Thread 类的 run() 方法。**
   2. **实现 Runnable 接口，重写 run() 方法。**
   3. **实现 Callable 接口，使用 FutureTask 类创建线程**
   4. **使用线程池创建、启动线程**

5. 说一下runnable和callable有什么区别？

   - Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，支持泛型
   - Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息

6. 线程有哪些状态？

   新建、就绪、运行、阻塞、死亡

7. sleep()和wait()有什么区别？

   - sleep() 是 Thread 类的静态本地方法；wait() 是Object类的成员本地方法
   - sleep() 方法可以在任何地方使用；wait() 方法则只能在同步方法或同步代码块中使用，否则抛出异常Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
   - sleep() 会休眠当前线程指定时间，释放 CPU 资源，不释放对象锁，休眠时间到自动苏醒继续执行；wait() 方法放弃持有的对象锁，进入等待队列，当该对象被调用 notify() / notifyAll() 方法后才有机会竞争获取对象锁，进入运行状态

8. notify()和notifyAll()有什么区别？

9. 线程的run()和start()有什么区别？

   1. 创建线程池有哪几种方式？

10. 线程池有哪些状态？

11. 线程池submit()和execute()方法有什么区别？

12. 在Java程序中怎么保证多线程的运行安全？

13. synchronized关键字的作用是什么？

    Java 中关键字 synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。

    - 确保线程互斥地访问同步代码
    - 保证共享变量的修改能够及时可见
    - 有效解决重排序问题

14. synchronized和volatile的区别是什么？

    **作用：**

    - synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。
    - volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。
      

    **区别：**

    - synchronized 可以作用于变量、方法、对象；volatile 只能作用于变量。
    - synchronized 可以保证线程间的有序性（个人猜测是无法保证线程内的有序性，即线程内的代码可能被 CPU 指令重排序）、原子性和可见性；volatile 只保证了可见性和有序性，无法保证原子性。
    - synchronized 线程阻塞，volatile 线程不阻塞。
    - volatile 本质是告诉 jvm 当前变量在寄存器中的值是不安全的需要从内存中读取；sychronized 则是锁定当前变量，只有当前线程可以访问到该变量其他线程被阻塞。
    - volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

15. synchronized和Lock有什么区别？

    - 实现层面不一样。synchronized 是 Java 关键字，JVM层面 实现加锁和释放锁；Lock 是一个接口，在代码层面实现加锁和释放锁
    - 是否自动释放锁。synchronized 在线程代码执行完或出现异常时自动释放锁；Lock 不会自动释放锁，需要再 finally {} 代码块显式地中释放锁
    - 是否一直等待。synchronized 会导致线程拿不到锁一直等待；Lock 可以设置尝试获取锁或者获取锁失败一定时间超时
    - 获取锁成功是否可知。synchronized 无法得知是否获取锁成功；Lock 可以通过 tryLock 获得加锁是否成功
    - 功能复杂性。synchronized 加锁可重入、不可中断、非公平；Lock 可重入、可判断、可公平和不公平、细分读写锁提高效率